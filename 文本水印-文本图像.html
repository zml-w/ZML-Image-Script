<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ComfyUI-ZML-Image的附属小工具</title>
    <!-- 引入 Google Fonts 中文字体，方便水印和文本图像使用 -->
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Noto Sans SC', sans-serif;
            margin: 20px;
            background-color: #f4f4f4;
            color: #333;
            line-height: 1.6;
            transition: background-color 0.3s, color 0.3s; /* Smooth theme transition */
        }
        /* Dark Mode Styles */
        body.dark-mode {
            background-color: #333;
            color: #f4f4f4;
        }
        body.dark-mode h1,
        body.dark-mode h2 {
            color: #8ab4f8; /* Lighter blue for dark mode */
            border-bottom-color: #555;
        }
        body.dark-mode .section {
            background-color: #444;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }
        body.dark-mode label {
            color: #ccc;
        }
        body.dark-mode input[type="text"],
        body.dark-mode input[type="number"],
        body.dark-mode textarea,
        body.dark-mode select {
            background-color: #555;
            border-color: #777;
            color: #eee;
        }
        body.dark-mode button {
            background-color: #6c757d; /* Darker gray for buttons in dark mode */
            color: white;
        }
        body.dark-mode button:hover {
            background-color: #5a6268;
        }
        body.dark-mode canvas {
            background-color: #666; /* Darker background for transparent images in dark mode */
        }
        body.dark-mode .help-box {
            background-color: #3f5f4b; /* Darker green background */
            border-color: #3d6e4d; /* Darker green border */
            color: #c3e6cb; /* Lighter green text */
        }
        /* Tab Button Styles for Dark Mode */
        body.dark-mode .tab-button#tabButtonWatermark {
            background-color: #2196F3; /* Blue for watermark in dark mode */
            color: white;
            border-color: #2196F3;
        }
        body.dark-mode .tab-button#tabButtonTextImage {
            background-color: #4CAF50; /* Green for textimage in dark mode */
            color: white;
            border-color: #4CAF50;
        }
        body.dark-mode .tab-button.active {
            background-color: #444; /* Active tab same as content in dark mode */
            border-bottom-color: #444;
            color: #eee;
        }
        body.dark-mode .tab-content {
            background-color: #444;
            border-color: #777;
        }
        body.dark-mode .active-section {
            border: 2px solid #8ab4f8 !important; /* Lighter blue for highlight in dark mode */
            box-shadow: 0 0 10px rgba(138, 180, 248, 0.5) !important;
        }


        h1, h2 {
            color: #0056b3;
            border-bottom: 2px solid #eee;
            padding-bottom: 10px;
            margin-top: 30px;
        }
        .container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-top: 20px;
        }
        .section {
            background-color: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            flex: 1;
            min-width: 400px;
            border: 2px solid transparent; /* Default border, transparent */
            transition: border-color 0.3s, box-shadow 0.3s, background-color 0.3s, color 0.3s; /* Smooth transition for highlight */
        }
        .active-section {
            border: 2px solid #007bff !important; /* Highlight border */
            box-shadow: 0 0 10px rgba(0,123,255,0.5) !important; /* Highlight shadow */
        }
        .form-group {
            margin-bottom: 15px;
            display: flex;
            flex-direction: column;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #555;
        }
        input[type="text"],
        input[type="number"],
        input[type="color"],
        textarea,
        select {
            width: calc(100% - 10px);
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 1em;
            transition: background-color 0.3s, color 0.3s, border-color 0.3s;
        }
        input[type="range"] {
            width: 100%;
        }
        textarea {
            resize: vertical;
            min-height: 80px;
        }
        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }
        button {
            padding: 10px 15px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
            transition: background-color 0.3s ease;
        }
        button:hover {
            background-color: #0056b3;
        }
        .output-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-top: 20px;
        }
        canvas {
            border: 1px solid #ccc;
            max-width: 100%;
            height: auto;
            display: block; /* 确保Canvas不会有额外的底部空间 */
            background-color: #eee; /* Light background for transparent images */
            margin-bottom: 20px; /* Space between canvas and buttons */
        }
        .help-box {
            background-color: #e9f7ef;
            border: 1px solid #d4edda;
            color: #155724;
            padding: 15px;
            border-radius: 5px;
            margin-top: 20px;
            font-size: 0.9em;
            white-space: pre-wrap; /* Preserve whitespace and line breaks */
            word-wrap: break-word; /* Break long words */
        }
        input[type="color"] {
            padding: 0; /* 颜色输入框重置padding */
            height: 34px; /* 确保高度一致 */
            width: 40px; /* 适当缩小宽度 */
            vertical-align: middle; /* 对齐 */
        }
        .color-input-group {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .color-input-group input[type="text"] {
            flex-grow: 1;
        }
        .tab-buttons {
            display: flex;
            margin-bottom: 20px;
            border-bottom: 1px solid #ccc; /* 添加一个底部分隔线 */
        }
        .tab-button {
            padding: 10px 15px;
            cursor: pointer;
            border: 1px solid transparent; /* 默认透明边框，只显示激活时的底部分界线 */
            border-bottom: none; /* 移除底部边框，让内容区域的边框连接 */
            background-color: #e0e0e0; /* Default grey background */
            font-weight: bold;
            border-top-left-radius: 5px;
            border-top-right-radius: 5px;
            flex-grow: 1; /* Make buttons take equal width */
            text-align: center;
            color: #333; /* Default text color */
            transition: background-color 0.3s, color 0.3s, border-color 0.3s;
        }
        /* Specific tab button colors */
        #tabButtonWatermark {
            background-color: #2196F3; /* Blue */
            color: white;
        }
        #tabButtonWatermark:hover {
            background-color: #1976D2;
        }
        #tabButtonTextImage {
            background-color: #4CAF50; /* Green */
            color: white;
        }
        #tabButtonTextImage:hover {
            background-color: #388E3C;
        }

        .tab-button.active {
            background-color: #fff; /* Active tab gets white background */
            border-left: 1px solid #ccc; /* Keep side borders */
            border-right: 1px solid #ccc;
            border-top: 1px solid #ccc;
            border-bottom: 1px solid #fff; /* Active tab's bottom border matches content background */
            color: #333; /* Active tab text color */
        }
        .tab-content {
            border: 1px solid #ccc;
            padding: 20px;
            border-radius: 0 0 8px 8px;
            background-color: #fff;
        }
        .hidden {
            display: none;
        }
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap; /* Allow wrapping on smaller screens */
        }
        .header h1 {
            margin: 0; /* Remove default margin from h1 in header */
            padding-bottom: 0;
            border-bottom: none;
        }
        .theme-toggle-button {
            padding: 8px 12px;
            background-color: #6c757d;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9em;
            transition: background-color 0.3s ease;
        }
        .theme-toggle-button:hover {
            background-color: #5a6268;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>ComfyUI-ZML-Image的附属小工具</h1>
        <button id="themeToggleButton" class="theme-toggle-button">切换主题</button>
    </div>

    <div class="tab-buttons">
        <button id="tabButtonWatermark" class="tab-button" onclick="showTab('watermark')">ZML_添加文字水印</button>
        <button id="tabButtonTextImage" class="tab-button" onclick="showTab('textToImage')">ZML_文本图像</button>
    </div>

    <div id="watermarkTab" class="tab-content">
        <h2>ZML_添加文字水印</h2>
        <div class="container">
            <div class="section input-section" id="watermarkInputSection">
                <h3>输入图像</h3>
                <div class="form-group">
                    <label for="watermarkImageUpload">上传图像:</label>
                    <input type="file" id="watermarkImageUpload" accept="image/*">
                </div>
                <h3>加载本地字体: <small>(优先级高于选择字体，仅TTF/OTF)</small></h3>
                <div class="form-group">
                     <label for="watermarkLocalFontUpload">上传字体文件:</label>
                     <input type="file" id="watermarkLocalFontUpload" accept=".ttf,.otf">
                     <small id="watermarkLocalFontStatus"></small>
                </div>
                <h3>水印参数</h3>
                <div class="form-group">
                    <label for="watermarkText">文本:</label>
                    <textarea id="watermarkText" placeholder="ZML_水印">ZML_水印</textarea>
                </div>
                <div class="form-group">
                    <label for="watermarkFontSize">字体大小:</label>
                    <input type="number" id="watermarkFontSize" value="48" min="8" max="1024">
                </div>
                <div class="form-group">
                    <label for="watermarkFont">字体 (在线谷歌字体和本地字体):</label>
                    <select id="watermarkFont">
                        <!-- Noto Sans SC 是一个很好的中文字体 -->
                        <option value="'Noto Sans SC', sans-serif">默认 (Noto Sans SC)</option> 
                        <option value="Arial, sans-serif">Arial</option>
                        <option value="Verdana, sans-serif">Verdana</option>
                        <option value="Times New Roman, serif">Times New Roman</option>
                        <option value="Courier New, monospace">Courier New</option>
                        <!-- Local font option will be added here by JS -->
                    </select>
                </div>
                <div class="form-group">
                    <label for="watermarkOpacity">不透明度:</label>
                    <input type="range" id="watermarkOpacity" value="0.7" min="0" max="1" step="0.01">
                    <span id="watermarkOpacityValue">0.7</span>
                </div>
                <div class="form-group">
                    <label>颜色:</label>
                    <div class="color-input-group">
                        <input type="text" id="watermarkColorText" value="#000000" placeholder="留空为透明字体; 输入'ZML'为随机填充色">
                        <input type="color" id="watermarkColorPicker" value="#000000">
                    </div>
                </div>
                <div class="form-group">
                    <label>描边颜色:</label>
                    <div class="color-input-group">
                        <input type="text" id="watermarkStrokeColorText" value="#FFFFFF" placeholder="留空则不描边; 输入'ZML'为随机颜色">
                        <input type="color" id="watermarkStrokeColorPicker" value="#FFFFFF">
                    </div>
                </div>
                <div class="form-group">
                    <label for="watermarkStrokeWidth">描边宽度:</label>
                    <input type="number" id="watermarkStrokeWidth" value="1" min="0" max="100">
                </div>
                <div class="form-group">
                    <label for="watermarkOrientation">书写方向:</label>
                    <select id="watermarkOrientation">
                        <option value="横排">横排</option>
                        <option value="竖排">竖排</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="watermarkPosition">位置:</label>
                    <select id="watermarkPosition">
                        <option value="左上">左上</option>
                        <option value="中上">中上</option>
                        <option value="右上">右上</option>
                        <option value="左中">左中</option>
                        <option value="居中">居中</option>
                        <option value="右中">右中</option>
                        <option value="左下">左下</option>
                        <option value="中下">中下</option>
                        <option value=" 右下">右下</option>
                        <option value="全屏">全屏</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="watermarkHorizontalMargin">水平边距:</label>
                    <input type="number" id="watermarkHorizontalMargin" value="20" min="0" max="4096">
                </div>
                <div class="form-group">
                    <label for="watermarkVerticalMargin">垂直边距:</label>
                    <input type="number" id="watermarkVerticalMargin" value="20" min="0" max="4096">
                </div>
                <div class="form-group">
                    <label for="watermarkCharSpacing">字符间距:</label>
                    <input type="number" id="watermarkCharSpacing" value="0" min="-50" max="100">
                </div>
                <div class="form-group">
                    <label for="watermarkLineSpacing">行间距:</label>
                    <input type="number" id="watermarkLineSpacing" value="10" min="-50" max="200">
                </div>
                <div class="form-group watermark-fullscreen-options">
                    <label for="watermarkRotationAngle">全屏水印旋转角度:</label>
                    <input type="number" id="watermarkRotationAngle" value="-30" min="-360" max="360">
                </div>
                <div class="form-group watermark-fullscreen-options">
                    <label for="watermarkDensity">全屏水印密度:</label>
                    <input type="range" id="watermarkDensity" value="1.0" min="0.5" max="5.0" step="0.1">
                    <span id="watermarkDensityValue">1.0</span>
                </div>
            </div>
            <div class="section output-section">
                <h3>处理结果 (右键点击图片可保存)</h3>
                <canvas id="watermarkCanvas"></canvas>
                <div class="button-group">
                    <button onclick="applyWatermark()">添加水印</button>
                    <button onclick="resetWatermarkForm()">重置参数</button>
                </div>
                <div class="help-box" id="watermarkHelp"></div>
            </div>
        </div>
    </div>

    <div id="textToImageTab" class="tab-content hidden">
        <h2>ZML_文本图像</h2>
        <div class="container">
            <div class="section input-section" id="textImageInputSection">
                <h3>加载本地字体: <small>(优先级高于选择字体，仅TTF/OTF)</small></h3>
                <div class="form-group">
                     <label for="textImageLocalFontUpload">上传字体文件:</label>
                     <input type="file" id="textImageLocalFontUpload" accept=".ttf,.otf">
                     <small id="textImageLocalFontStatus"></small>
                </div>
                <h3>文本图像参数</h3>
                <div class="form-group">
                    <label for="textImageText">文本:</label>
                    <textarea id="textImageText" placeholder="ZML_文本">ZML_文本</textarea>
                </div>
                <div class="form-group">
                    <label for="textImageFontSize">字体大小:</label>
                    <input type="number" id="textImageFontSize" value="48" min="1" max="1024">
                </div>
                <div class="form-group">
                    <label for="textImageFont">字体 (在线谷歌字体和本地字体):</label>
                    <select id="textImageFont">
                        <option value="'Noto Sans SC', sans-serif">默认 (Noto Sans SC)</option>
                        <option value="Arial, sans-serif">Arial</option>
                        <option value="Verdana, sans-serif">Verdana</option>
                        <option value="Times New Roman, serif">Times New Roman</option>
                        <option value="Courier New, monospace">Courier New</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="textImageOpacity">不透明度:</label>
                    <input type="range" id="textImageOpacity" value="1.0" min="0.0" max="1.0" step="0.01">
                    <span id="textImageOpacityValue">1.0</span>
                </div>
                <div class="form-group">
                    <label>颜色:</label>
                    <div class="color-input-group">
                        <input type="text" id="textImageColorText" value="#000000" placeholder="留空为透明字体; 输入'ZML'为随机填充色">
                        <input type="color" id="textImageColorPicker" value="#000000">
                    </div>
                </div>
                <div class="form-group">
                    <label>描边颜色:</label>
                    <div class="color-input-group">
                        <input type="text" id="textImageStrokeColorText" value="#FFFFFF" placeholder="留空则不描边; 输入'ZML'为随机颜色">
                        <input type="color" id="textImageStrokeColorPicker" value="#FFFFFF">
                    </div>
                </div>
                <div class="form-group">
                    <label for="textImageStrokeWidth">描边宽度:</label>
                    <input type="number" id="textImageStrokeWidth" value="1" min="0" max="100">
                </div>
                <div class="form-group">
                    <label for="textImageOrientation">书写方向:</label>
                    <select id="textImageOrientation">
                        <option value="横排">横排</option>
                        <option value="竖排">竖排</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="textImageHorizontalMargin">水平边距:</label>
                    <input type="number" id="textImageHorizontalMargin" value="20" min="0" max="4096">
                </div>
                <div class="form-group">
                    <label for="textImageVerticalMargin">垂直边距:</label>
                    <input type="number" id="textImageVerticalMargin" value="20" min="0" max="4096">
                </div>
                <div class="form-group">
                    <label for="textImageCharSpacing">字符间距:</label>
                    <input type="number" id="textImageCharSpacing" value="0" min="-50" max="100">
                </div>
                <div class="form-group">
                    <label for="textImageLineSpacing">行间距:</label>
                    <input type="number" id="textImageLineSpacing" value="10" min="-50" max="200">
                </div>
                <div class="form-group">
                    <label for="textImageBgColor">背景颜色:</label>
                    <select id="textImageBgColor">
                        <option value="透明">透明</option>
                        <option value="白色">白色</option>
                        <option value="黑色">黑色</option>
                        <option value="红色">红色</option>
                        <option value="蓝色">蓝色</option>
                        <option value="黄色">黄色</option>
                        <option value="绿色">绿色</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="textImageSizeMode">图像大小模式:</label>
                    <select id="textImageSizeMode">
                        <option value="根据字体大小决定图像尺寸">根据字体大小决定图像尺寸</option>
                        <option value="根据图像尺寸决定字体大小">根据图像尺寸决定字体大小</option>
                        <option value="字体大小和图像尺寸独立计算">字体大小和图像尺寸独立计算</option>
                    </select>
                </div>
                <div class="form-group text-image-size-inputs">
                    <label for="textImageWidth">图像宽:</label>
                    <input type="number" id="textImageWidth" value="512" min="1" max="8192" step="8">
                </div>
                <div class="form-group text-image-size-inputs">
                    <label for="textImageHeight">图像高:</label>
                    <input type="number" id="textImageHeight" value="512" min="1" max="8192" step="8">
                </div>

            </div>
            <div class="section output-section">
                <h3>处理结果 (右键点击图片可保存)</h3>
                <canvas id="textImageCanvas"></canvas>
                <div class="button-group">
                    <button onclick="generateTextImage()">生成文本图像</button>
                    <button onclick="resetTextImageForm()">重置参数</button>
                </div>
                <div class="help-box" id="textImageHelp"></div>
            </div>
        </div>
    </div>


    <script>
        // ========================================== 全局工具函数 ==========================================
        /**
         * 将十六进制颜色代码转换为RGBA颜色字符串。
         * @param {string} hex - 十六进制颜色代码，例如 "#RRGGBB"。
         * @param {number} opacity - 不透明度，0.0 到 1.0 之间。
         * @returns {string} RGBA颜色字符串，例如 "rgba(R, G, B, A)"。
         */
        function hexToRgba(hex, opacity) {
            let r = 0, g = 0, b = 0;
            // 确保 hex 格式正确，去除可能存在的 #
            if (!hex || hex.trim() === '') return `rgba(0,0,0,0)`; // 如果是空字符串或null，则透明
            hex = hex.trim().startsWith('#') ? hex.trim() : '#' + hex.trim(); // 确保有 #

            if (hex.length === 7) { // #RRGGBB
                r = parseInt(hex.substring(1, 3), 16);
                g = parseInt(hex.substring(3, 5), 16);
                b = parseInt(hex.substring(5, 7), 16);
            } else if (hex.length === 4) { // #RGB (简写)
                r = parseInt(hex[1] + hex[1], 16);
                g = parseInt(hex[2] + hex[2], 16);
                b = parseInt(hex[3] + hex[3], 16);
            } else {
                return `rgba(0,0,0,0)`; // 无效格式，返回透明
            }
            return `rgba(${r}, ${g}, ${b}, ${opacity})`;
        }

        /**
         * 生成一个随机的RGBA颜色字符串。
         * 模拟Python中的 'ZML' 随机色，这里生成的是任意随机色。
         * @param {number} opacity - 不透明度，0.0 到 1.0 之间。
         * @returns {string} 随机RGBA颜色字符串。
         */
        function getRandomRgba(opacity) {
            const r = Math.floor(Math.random() * 256);
            const g = Math.floor(Math.random() * 256);
            const b = Math.floor(Math.random() * 256);
            return `rgba(${r}, ${g}, ${b}, ${opacity})`;
        }

        /**
         * 获取文本行在Canvas上绘制的宽度和高度。
         * @param {CanvasRenderingContext2D} ctx - Canvas 2D 渲染上下文。
         * @param {string[]} lines - 文本行数组。
         * @param {number} charSpacing - 字符间距。
         * @param {number} lineSpacing - 行间距。
         * @param {string} orientation - "横排" 或 "竖排"。
         * @param {number} strokeWidth - 描边宽度，用于调整计算。
         * @returns {{width: number, height: number}} 文本块的实际宽度和高度。
         */
        function getTextBlockSize(ctx, lines, charSpacing, lineSpacing, orientation, strokeWidth = 0) {
            if (lines.length === 0) return { width: 0, height: 0 };

            let maxWidth = 0;
            let totalHeight = 0;
            
            // Helper to get bounding box info for a character
            function getCharMetrics(char) {
                const metrics = ctx.measureText(char);
                return {
                    width: metrics.width,
                    height: (metrics.actualBoundingBoxAscent || 0) + (metrics.actualBoundingBoxDescent || 0)
                };
            }

            if (orientation === "横排") {
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i];
                    let currentLineW = 0;
                    let currentLineH = 0;

                    if (line) {
                        for (let j = 0; j < line.length; j++) {
                            const char = line[j];
                            const { width, height } = getCharMetrics(char);
                            currentLineW += width + charSpacing;
                            currentLineH = Math.max(currentLineH, height);
                        }
                        currentLineW = Math.max(0, currentLineW - charSpacing); // 减去最后一个字符的间距
                    } else { // 空行
                        currentLineH = getCharMetrics("M").height || (ctx.font.match(/(\d+)px/)?.[1] || 0); // Use a character height to simulate empty line height
                    }

                    maxWidth = Math.max(maxWidth, currentLineW);
                    totalHeight += currentLineH;
                    if (i < lines.length - 1) {
                        totalHeight += lineSpacing;
                    }
                }
                // 考虑描边对整体尺寸的影响
                return { width: maxWidth + (strokeWidth * 2), height: totalHeight + (strokeWidth * 2) };
            } else { // 竖排
                let totalWidth = 0;
                let maxHeight = 0;

                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i];
                    let currentLineH = 0;
                    let currentLineW = 0;

                    if (line) {
                        for (let j = 0; j < line.length; j++) {
                            const char = line[j];
                            const { width, height } = getCharMetrics(char);
                            currentLineH += height + charSpacing;
                            currentLineW = Math.max(currentLineW, width);
                        }
                        currentLineH = Math.max(0, currentLineH - charSpacing); // 减去最后一个字符的间距
                    } else { // 空行
                        currentLineW = getCharMetrics("M").width || (ctx.font.match(/(\d+)px/)?.[1] || 0); // Use a character width to simulate empty line width
                    }

                    totalWidth += currentLineW;
                    maxHeight = Math.max(maxHeight, currentLineH);
                    if (i < lines.length - 1) {
                        totalWidth += lineSpacing;
                    }
                }
                return { width: totalWidth + (strokeWidth * 2), height: maxHeight + (strokeWidth * 2) };
            }
        }

        /**
         * 根据最大维度准备文本行，实现自动换行。
         * @param {CanvasRenderingContext2D} ctx - Canvas 2D 渲染上下文。
         * @param {string} text - 原始文本。
         * @param {number} charSpacing - 字符间距。
         * @param {string} orientation - "横排" 或 "竖排"。
         * @param {number} [maxDim=Infinity] - 最大允许的维度（宽度或高度），用于自动换行。
         * @returns {string[]} 处理后的文本行数组。
         */
        function prepareLines(ctx, text, charSpacing, orientation, maxDim = Infinity) {
            const lines = [];
            const paragraphs = text.split('\n');

            for (const p of paragraphs) {
                if (!p) {
                    lines.push(""); // Preserve empty lines from original text
                    continue;
                }

                let currentLine = "";
                let currentDim = 0;

                for (const char of p) {
                    const metrics = ctx.measureText(char);
                    // Use actualBoundingBoxAscent and Desc for height in vertical mode
                    const charDim = orientation === "横排" ? metrics.width : ((metrics.actualBoundingBoxAscent || 0) + (metrics.actualBoundingBoxDescent || 0));

                    if (maxDim !== Infinity && currentDim + charDim + charSpacing > maxDim && currentLine) {
                        // If adding char exceeds maxDim and line is not empty, start a new line
                        lines.push(currentLine);
                        currentLine = char;
                        currentDim = charDim + charSpacing;
                    } else {
                        currentLine += char;
                        currentDim += charDim + charSpacing;
                    }
                }
                if (currentLine) {
                    lines.push(currentLine);
                }
            }
            return lines;
        }


        /**
         * 手动绘制文本，支持描边和字符/行间距。
         * @param {CanvasRenderingContext2D} ctx - Canvas 2D 渲染上下文。
         * @param {string[]} lines - 预处理的文本行数组。
         * @param {number} startX - 绘制起始X坐标。
         * @param {number} startY - 绘制起始Y坐标。
         * @param {string|null} fillColorParam - 填充颜色参数（#hex, 'transparent' 或 'ZML'）。
         * @param {number} strokeWidth - 描边宽度。
         * @param {string|null} strokeColorParam - 描边颜色参数（#hex, 'transparent' 或 'ZML'）。
         * @param {number} opacity - 总体不透明度。
         * @param {number} charSpacing - 字符间距。
         * @param {number} lineSpacing - 行间距。
         * @param {string} orientation - "横排" 或 "竖排"。
         */
        function drawTextManually(ctx, lines, startX, startY, fillColorParam, strokeWidth, strokeColorParam, opacity, charSpacing, lineSpacing, orientation) {
            let cursorX = startX;
            let cursorY = startY;

            // 获取实际的填充颜色
            function getActualFillColor(colorParam) {
                if (!colorParam || colorParam.trim() === '') {
                    return `rgba(0, 0, 0, 0)`; // 完全透明
                } else if (colorParam.trim().toLowerCase() === 'zml') {
                    return getRandomRgba(opacity);
                } else {
                    return hexToRgba(colorParam, opacity);
                }
            }

            // 获取实际的描边颜色
            function getActualStrokeColor(colorParam) {
                if (strokeWidth === 0 || !colorParam || colorParam.trim() === '') {
                    return `rgba(0, 0, 0, 0)`; // 描边宽度为0或颜色透明，则描边也透明
                } else if (colorParam.trim().toLowerCase() === 'zml') {
                    return getRandomRgba(opacity);
                } else {
                    return hexToRgba(colorParam, opacity);
                }
            }
            
            ctx.lineJoin = 'round'; // 使描边连接更平滑
            ctx.lineCap = 'round';   // 使描边端点更圆润

            if (orientation === "横排") {
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i];
                    let currentLineHeight = 0;
                    if (line) {
                         // 获取当前行中所有字符的最大高度
                        currentLineHeight = Math.max(...line.split('').map(c => {
                            const metrics = ctx.measureText(c);
                            return (metrics.actualBoundingBoxAscent || 0) + (metrics.actualBoundingBoxDescent || 0);
                        }));
                    } else {
                        // 空行的高度，模拟一个M字符的高度
                        const metrics = ctx.measureText("M");
                        currentLineHeight = (metrics.actualBoundingBoxAscent || 0) + (metrics.actualBoundingBoxDescent || 0);
                    }


                    for (let j = 0; j < line.length; j++) {
                        const char = line[j];
                        
                        // 每次绘制字符前，重新获取颜色（如果使用ZML随机色模式）
                        const charFill = getActualFillColor(fillColorParam);
                        const charStroke = getActualStrokeColor(strokeColorParam);

                        if (strokeWidth > 0) {
                            ctx.strokeStyle = charStroke;
                            ctx.lineWidth = strokeWidth;
                            // Canvas Y坐标是基线，需要调整。fillText和strokeText会根据这个基线绘制。
                            // 为了让文本顶部对齐currentLineHeight，我们绘制时加上 ascent
                            ctx.strokeText(char, cursorX, cursorY + (ctx.measureText(char).actualBoundingBoxAscent || 0)); 
                        }
                        ctx.fillStyle = charFill;
                        ctx.fillText(char, cursorX, cursorY + (ctx.measureText(char).actualBoundingBoxAscent || 0)); 

                        cursorX += ctx.measureText(char).width + charSpacing;
                    }
                    cursorX = startX;
                    cursorY += currentLineHeight + lineSpacing;
                }
            } else { // 竖排 (Simplified - actual vertical text layout in Canvas is complex)
                // Canvas 不直接支持竖排文本，需要手动绘制每个字符并计算位置
                // 这里我们模拟 ComfyUI 的竖排逻辑：字符竖向排列，行横向排列
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i];
                    let currentLineMaxWidth = 0;
                    if (line) {
                        currentLineMaxWidth = Math.max(...line.split('').map(c => ctx.measureText(c).width));
                    } else {
                         const metrics = ctx.measureText("M");
                         currentLineMaxWidth = metrics.width;
                    }

                    for (let j = 0; j < line.length; j++) {
                        const char = line[j];
                        
                        const charMetrics = ctx.measureText(char);
                        const charRenderHeight = (charMetrics.actualBoundingBoxAscent || 0) + (charMetrics.actualBoundingBoxDescent || 0);

                        // 每次绘制字符前，重新获取颜色（如果使用ZML随机色模式）
                        const charFill = getActualFillColor(fillColorParam);
                        const charStroke = getActualStrokeColor(strokeColorParam);

                        // 竖排时，x 坐标保持不变，y 坐标递增
                        if (strokeWidth > 0) {
                            ctx.strokeStyle = charStroke;
                            ctx.lineWidth = strokeWidth;
                            ctx.strokeText(char, cursorX, cursorY + (charMetrics.actualBoundingBoxAscent || 0));
                        }
                        ctx.fillStyle = charFill;
                        ctx.fillText(char, cursorX, cursorY + (charMetrics.actualBoundingBoxAscent || 0));
                        
                        cursorY += charRenderHeight + charSpacing;
                    }
                    cursorY = startY;
                    cursorX += currentLineMaxWidth + lineSpacing;
                }
            }
        }

        /**
         * 更新计数器并返回新的计数，存储在 localStorage 中。
         * @param {string} key - 计数器的键名。
         * @returns {number} 更新后的计数。
         */
        function updateCounter(key) {
            let count = parseInt(localStorage.getItem(key) || '0', 10);
            count++;
            localStorage.setItem(key, count);
            return count;
        }
        
        // ========================================== 本地字体加载功能 ==========================================
        let localFontFamily = null; // To store the custom font family name
        let localFontAdded = false; // To track if custom font has been added to CSS

        function loadLocalFont(file, canvasId, fontSelectId, statusElementId) {
            if (!file) {
                document.getElementById(statusElementId).textContent = "请选择一个字体文件。";
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                const fontData = e.target.result;
                // Generate a unique font family name
                const fontFileName = file.name.split('.').slice(0, -1).join('.');
                const customFontName = `CustomFont-${fontFileName.replace(/[^a-zA-Z0-9]/g, '_')}-${Date.now()}`;
                localFontFamily = customFontName;

                // Create a style element to add the @font-face rule
                const style = document.createElement('style');
                style.textContent = `
                    @font-face {
                        font-family: '${customFontName}';
                        src: url('${fontData}') format('opentype'); /* or truetype for TTF */
                        font-weight: normal;
                        font-style: normal;
                    }
                `;
                document.head.appendChild(style);
                localFontAdded = true;

                // Add the new font to the font select dropdown
                const fontSelect = document.getElementById(fontSelectId);
                let option = fontSelect.querySelector(`option[value='${customFontName}']`);
                if (!option) {
                    option = document.createElement('option');
                    option.value = customFontName;
                    option.textContent = `本地字体: ${fontFileName}`;
                    fontSelect.appendChild(option);
                }
                fontSelect.value = customFontName; // Select the newly loaded font

                document.getElementById(statusElementId).textContent = `字体 "${fontFileName}" 加载成功！已自动选中。`;

                // Try to render some text with the new font to ensure it's loaded before actual use
                // This is a common pattern to force browser to load font asset
                const testCanvas = document.createElement('canvas');
                const testCtx = testCanvas.getContext('2d');
                testCtx.font = `1px '${customFontName}'`;
                testCtx.fillText('test', 0, 0); // Force render

                // A slight delay to ensure font is rendered and available
                setTimeout(() => {
                    // Re-apply watermark/generate text image with new font
                    if (canvasId === 'watermarkCanvas') {
                        applyWatermark(false); 
                    } else if (canvasId === 'textImageCanvas') {
                        generateTextImage();
                    }
                }, 100); 

            };
            reader.onerror = function() {
                document.getElementById(statusElementId).textContent = "字体文件读取失败。";
                localFontFamily = null;
                localFontAdded = false;
            };
            reader.readAsDataURL(file);
        }

        // ========================================== ZML_添加文字水印 功能 ==========================================
        let watermarkImage = null; // 存储用户上传的图像

        document.getElementById('watermarkImageUpload').addEventListener('change', function(event) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const img = new Image();
                    img.onload = function() {
                        watermarkImage = img;
                        console.log("水印图像加载成功:", img.width, img.height);
                        // 图像加载后，自动应用一次水印
                        applyWatermark(true); 
                    };
                    img.onerror = function() {
                        console.error("图像加载失败。");
                        watermarkImage = null;
                        // 清空 Canvas
                        const canvas = document.getElementById('watermarkCanvas');
                        const ctx = canvas.getContext('2d');
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                         canvas.width = 0; // 隐藏 Canvas
                         canvas.height = 0;
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            } else {
                watermarkImage = null;
                const canvas = document.getElementById('watermarkCanvas');
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height); // 清空 Canvas
                canvas.width = 0; canvas.height = 0; // 隐藏 Canvas
            }
            // 每次文件选择后，更新全屏水印选项的可见性
            updateWatermarkFullscreenOptionsVisibility();
        });

        document.getElementById('watermarkLocalFontUpload').addEventListener('change', function(event) {
            const file = event.target.files[0];
            if (file) {
                 loadLocalFont(file, 'watermarkCanvas', 'watermarkFont', 'watermarkLocalFontStatus');
            }
        });

        document.getElementById('watermarkOpacity').addEventListener('input', (event) => {
            document.getElementById('watermarkOpacityValue').textContent = event.target.value;
        });
        document.getElementById('watermarkDensity').addEventListener('input', (event) => {
            document.getElementById('watermarkDensityValue').textContent = event.target.value;
        });

        document.getElementById('watermarkColorPicker').addEventListener('input', (event) => {
            // Only update text field if picker is used. Text field can contain 'ZML' or be empty.
            if (event.isTrusted) { // Check if triggered by user interaction
                document.getElementById('watermarkColorText').value = event.target.value;
            }
        });
        document.getElementById('watermarkColorText').addEventListener('input', (event) => {
            // Try to update color picker if input is a valid hex.
            // Avoids setting picker to a non-hex value like 'ZML' or empty.
            if (/^#([0-9A-Fa-f]{6}|[0-9A-Fa-f]{3})$/.test(event.target.value)) {
                document.getElementById('watermarkColorPicker').value = event.target.value;
            }
        });

        document.getElementById('watermarkStrokeColorPicker').addEventListener('input', (event) => {
            if (event.isTrusted) {
                document.getElementById('watermarkStrokeColorText').value = event.target.value;
            }
        });
        document.getElementById('watermarkStrokeColorText').addEventListener('input', (event) => {
            if (/^#([0-9A-Fa-f]{6}|[0-9A-Fa-f]{3})$/.test(event.target.value)) {
                document.getElementById('watermarkStrokeColorPicker').value = event.target.value;
            }
        });

        document.getElementById('watermarkPosition').addEventListener('change', updateWatermarkFullscreenOptionsVisibility);

        function updateWatermarkFullscreenOptionsVisibility() {
            const position = document.getElementById('watermarkPosition').value;
            const fullscreenOptions = document.querySelectorAll('.watermark-fullscreen-options');
            fullscreenOptions.forEach(el => {
                if (position === '全屏') {
                    el.style.display = 'block';
                } else {
                    el.style.display = 'none';
                }
            });
        }
        
        /**
         * 应用水印到图像。
         * @param {boolean} isInitialLoad - 是否是初始加载导致的水印应用（不增加计数器）。
         */
        function applyWatermark(isInitialLoad = false) {
            const canvas = document.getElementById('watermarkCanvas');
            const ctx = canvas.getContext('2d');

            if (!watermarkImage) {
                // 如果没有图像，清空画布并显示提示
                canvas.width = 0; // 隐藏Canvas
                canvas.height = 0;
                document.getElementById('watermarkHelp').textContent = '请先上传图像以应用水印。';
                return;
            }

            // Set canvas size to image size
            canvas.width = watermarkImage.width;
            canvas.height = watermarkImage.height;

            // Draw the base image
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(watermarkImage, 0, 0);

            // Get parameters
            const text = document.getElementById('watermarkText').value;
            const fontSize = parseInt(document.getElementById('watermarkFontSize').value);
            const fontSelectValue = document.getElementById('watermarkFont').value;
            const fontStyle = localFontFamily && localFontAdded ? `'${localFontFamily}'` : fontSelectValue; // Use local font if loaded, else selected font
            
            const opacity = parseFloat(document.getElementById('watermarkOpacity').value);
            const colorText = document.getElementById('watermarkColorText').value;
            const strokeWidth = parseInt(document.getElementById('watermarkStrokeWidth').value);
            const strokeColorText = document.getElementById('watermarkStrokeColorText').value;
            const orientation = document.getElementById('watermarkOrientation').value;
            const position = document.getElementById('watermarkPosition').value;
            const horizontalMargin = parseInt(document.getElementById('watermarkHorizontalMargin').value);
            const verticalMargin = parseInt(document.getElementById('watermarkVerticalMargin').value);
            const charSpacing = parseInt(document.getElementById('watermarkCharSpacing').value);
            const lineSpacing = parseInt(document.getElementById('watermarkLineSpacing').value);
            const rotationAngle = parseInt(document.getElementById('watermarkRotationAngle').value);
            const density = parseFloat(document.getElementById('watermarkDensity').value);

            ctx.font = `${fontSize}px ${fontStyle}`;

            if (position === "全屏") {
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                
                tempCtx.font = ctx.font; // Use the same font settings for measurement and drawing
                const textLines = prepareLines(tempCtx, text, charSpacing, orientation);
                const { width: textBlockWidth, height: textBlockHeight } = getTextBlockSize(tempCtx, textLines, charSpacing, lineSpacing, orientation, strokeWidth);

                if (textBlockWidth <= 0 || textBlockHeight <= 0) {
                    document.getElementById('watermarkHelp').innerHTML = "全屏水印文本尺寸为0或负数，跳过绘制。请检查文本或字体大小。";
                    return;
                }

                // Create a temporary canvas for a single watermark tile
                const tileCanvasWidth = textBlockWidth + (strokeWidth * 2); // account for stroke width
                const tileCanvasHeight = textBlockHeight + (strokeWidth * 2); // account for stroke width
                const tileCanvas = document.createElement('canvas');
                tileCanvas.width = Math.max(1, tileCanvasWidth); // Ensure minimum 1px dimension
                tileCanvas.height = Math.max(1, tileCanvasHeight);
                const tileCtx = tileCanvas.getContext('2d');
                tileCtx.font = ctx.font; // Apply font to tileCtx
                
                // Draw single tile text
                drawTextManually(tileCtx, textLines, strokeWidth, strokeWidth, colorText, strokeWidth, strokeColorText, opacity, charSpacing, lineSpacing, orientation);

                // Rotate the tile
                const rotatedCanvas = document.createElement('canvas');
                const rotatedCtx = rotatedCanvas.getContext('2d');
                
                // Calculate new dimensions after rotation
                const angleRad = rotationAngle * Math.PI / 180;
                const absCos = Math.abs(Math.cos(angleRad));
                const absSin = Math.abs(Math.sin(angleRad));
                const rotatedWidth = tileCanvas.width * absCos + tileCanvas.height * absSin;
                const rotatedHeight = tileCanvas.width * absSin + tileCanvas.height * absCos;

                rotatedCanvas.width = rotatedWidth;
                rotatedCanvas.height = rotatedHeight;

                // Move origin to center for rotation
                rotatedCtx.translate(rotatedWidth / 2, rotatedHeight / 2);
                rotatedCtx.rotate(angleRad);
                rotatedCtx.drawImage(tileCanvas, -tileCanvasWidth / 2, -tileCanvasHeight / 2);
                rotatedCtx.setTransform(1, 0, 0, 1, 0, 0); // Reset transform

                const sx = Math.max(1, Math.floor((rotatedCanvas.width + horizontalMargin) / density));
                const sy = Math.max(1, Math.floor((rotatedCanvas.height + verticalMargin) / density));
                const offset = sx / 2;
                let rowIdx = 0;

                // Fill the main canvas with rotated tiles
                for (let y = -rotatedCanvas.height; y < canvas.height; y += sy) {
                    const startX = -rotatedCanvas.width + (rowIdx % 2 !== 0 ? offset : 0);
                    for (let x = startX; x < canvas.width; x += sx) {
                        ctx.drawImage(rotatedCanvas, x, y);
                    }
                    rowIdx++;
                }

            } else { // 定位水印
                // Max dimension needs to account for stroke width for preparation
                const maxDimForPrep = (orientation === "横排" ? canvas.width - (horizontalMargin * 2) : canvas.height - (verticalMargin * 2));
                const textLines = prepareLines(ctx, text, charSpacing, orientation, maxDimForPrep - (strokeWidth * 2));
                const { width: textBlockWidth, height: textBlockHeight } = getTextBlockSize(ctx, textLines, charSpacing, lineSpacing, orientation, strokeWidth);

                let x, y;
                // 计算文本区域的起始绘制位置
                const effectiveHMargin = horizontalMargin + strokeWidth;
                const effectiveVMargin = verticalMargin + strokeWidth;

                 if (position.includes("左")) {
                    x = effectiveHMargin;
                } else if (position.includes("右")) {
                    x = canvas.width - textBlockWidth - effectiveHMargin;
                } else { // 居中
                    x = (canvas.width - textBlockWidth) / 2;
                }

                if (position.includes("上")) {
                    y = effectiveVMargin;
                } else if (position.includes("下")) {
                    y = canvas.height - textBlockHeight - effectiveVMargin;
                } else { // 居中
                    y = (canvas.height - textBlockHeight) / 2;
                }
                
                // 进行绘制
                drawTextManually(ctx, textLines, x, y, colorText, strokeWidth, strokeColorText, opacity, charSpacing, lineSpacing, orientation);
            }

            if (!isInitialLoad) {
                const count = updateCounter('watermarkCount');
                document.getElementById('watermarkHelp').innerHTML = `你好，欢迎使用ZML节点~到目前为止，你通过此节点总共添加了${count}次水印！！\n\n此工具提取自：“<a href="https://github.com/zml-w/ComfyUI-ZML-Image" target="_blank">https://github.com/zml-w/ComfyUI-ZML-Image</a>”里的节点。\n\n您可以使用浏览器（通常是右键点击图片）来保存生成的图片。祝你天天开心~`;
            } else {
                 const count = parseInt(localStorage.getItem('watermarkCount') || '0', 10);
                 document.getElementById('watermarkHelp').innerHTML = `你好，欢迎使用ZML节点~到目前为止，你通过此节点总共添加了${count}次水印！！\n\n此工具提取自：“<a href="https://github.com/zml-w/ComfyUI-ZML-Image" target="_blank">https://github.com/zml-w/ComfyUI-ZML-Image</a>”里的节点。\n\n您可以使用浏览器（通常是右键点击图片）来保存生成的图片。祝你天天开心~`;
            }
        }

        function resetWatermarkForm() {
            document.getElementById('watermarkImageUpload').value = '';
            watermarkImage = null;
            document.getElementById('watermarkLocalFontUpload').value = ''; // Clear local font input
            document.getElementById('watermarkLocalFontStatus').textContent = ''; // Clear status
            localFontFamily = null;
            localFontAdded = false;

            document.getElementById('watermarkText').value = 'ZML_水印';
            document.getElementById('watermarkFontSize').value = 48;
            document.getElementById('watermarkFont').value = "'Noto Sans SC', sans-serif";
            document.getElementById('watermarkOpacity').value = 0.7;
            document.getElementById('watermarkOpacityValue').textContent = "0.7";
            document.getElementById('watermarkColorText').value = '#000000';
            document.getElementById('watermarkColorPicker').value = '#000000';
            document.getElementById('watermarkStrokeWidth').value = 1;
            document.getElementById('watermarkStrokeColorText').value = '#FFFFFF';
            document.getElementById('watermarkStrokeColorPicker').value = '#FFFFFF';
            document.getElementById('watermarkOrientation').value = '横排';
            document.getElementById('watermarkPosition').value = '居中';
            document.getElementById('watermarkHorizontalMargin').value = 20;
            document.getElementById('watermarkVerticalMargin').value = 20;
            document.getElementById('watermarkCharSpacing').value = 0;
            document.getElementById('watermarkLineSpacing').value = 10;
            document.getElementById('watermarkRotationAngle').value = -30;
            document.getElementById('watermarkDensity').value = 1.0;
            document.getElementById('watermarkDensityValue').textContent = "1.0";
            
            const canvas = document.getElementById('watermarkCanvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            canvas.width = 0; // Effectively hide the canvas
            canvas.height = 0;
            
            updateWatermarkFullscreenOptionsVisibility();

            document.getElementById('watermarkHelp').innerHTML = `参数已重置。\n\n此工具提取自：“<a href="https://github.com/zml-w/ComfyUI-ZML-Image" target="_blank">https://github.com/zml-w/ComfyUI-ZML-Image</a>”里的节点。\n\n您可以使用浏览器（通常是右键点击图片）来保存生成的图片。祝你天天开心~`;
        }


        // ========================================== ZML_文本图像 功能 ==========================================
        // No need for separate textImageLocalFontFamily and localFontAdded, just use global ones
        // let textImageLocalFontFamily = null; 
        // let textImageLocalFontAdded = false;

        document.getElementById('textImageLocalFontUpload').addEventListener('change', function(event) {
            const file = event.target.files[0];
            if (file) {
                 loadLocalFont(file, 'textImageCanvas', 'textImageFont', 'textImageLocalFontStatus');
            }
        });


        document.getElementById('textImageOpacity').addEventListener('input', (event) => {
            document.getElementById('textImageOpacityValue').textContent = event.target.value;
        });

        document.getElementById('textImageColorPicker').addEventListener('input', (event) => {
             if (event.isTrusted) {
                document.getElementById('textImageColorText').value = event.target.value;
            }
        });
        document.getElementById('textImageColorText').addEventListener('input', (event) => {
            if (/^#([0-9A-Fa-f]{6}|[0-9A-Fa-f]{3})$/.test(event.target.value)) {
                document.getElementById('textImageColorPicker').value = event.target.value;
            }
        });

        document.getElementById('textImageStrokeColorPicker').addEventListener('input', (event) => {
            if (event.isTrusted) {
                document.getElementById('textImageStrokeColorText').value = event.target.value;
            }
        });
        document.getElementById('textImageStrokeColorText').addEventListener('input', (event) => {
            if (/^#([0-9A-Fa-f]{6}|[0-9A-Fa-f]{3})$/.test(event.target.value)) {
                document.getElementById('textImageStrokeColorPicker').value = event.target.value;
            }
        });


        document.getElementById('textImageSizeMode').addEventListener('change', function() {
            const sizeMode = this.value;
            const sizeInputs = document.querySelectorAll('.text-image-size-inputs');
            if (sizeMode === '根据字体大小决定图像尺寸') {
                sizeInputs.forEach(input => input.style.display = 'none');
            } else {
                sizeInputs.forEach(input => input.style.display = 'flex');
            }
        });
        
        function generateTextImage() {
            const canvas = document.getElementById('textImageCanvas');
            const ctx = canvas.getContext('2d');

            const text = document.getElementById('textImageText').value;
            let fontSize = parseInt(document.getElementById('textImageFontSize').value);
            const fontSelectValue = document.getElementById('textImageFont').value;
            const fontStyle = localFontFamily && localFontAdded ? `'${localFontFamily}'` : fontSelectValue; // Use local font if loaded, else selected font

            const opacity = parseFloat(document.getElementById('textImageOpacity').value);
            const colorText = document.getElementById('textImageColorText').value;
            const strokeWidth = parseInt(document.getElementById('textImageStrokeWidth').value);
            const strokeColorText = document.getElementById('textImageStrokeColorText').value;
            const orientation = document.getElementById('textImageOrientation').value;
            const horizontalMargin = parseInt(document.getElementById('textImageHorizontalMargin').value);
            const verticalMargin = parseInt(document.getElementById('textImageVerticalMargin').value);
            const charSpacing = parseInt(document.getElementById('textImageCharSpacing').value);
            const lineSpacing = parseInt(document.getElementById('textImageLineSpacing').value);
            const bgColorName = document.getElementById('textImageBgColor').value;
            const imageSizeMode = document.getElementById('textImageSizeMode').value;
            let imageWidth = parseInt(document.getElementById('textImageWidth').value);
            let imageHeight = parseInt(document.getElementById('textImageHeight').value);

            // 背景颜色映射
            const bg_color_map = {
                "透明": "rgba(0, 0, 0, 0)",
                "白色": "rgba(255, 255, 255, 255)",
                "黑色": "rgba(0, 0, 0, 255)",
                "红色": "rgba(255, 0, 0, 255)",
                "蓝色": "rgba(0, 0, 255, 255)",
                "黄色": "rgba(255, 255, 0, 255)",
                "绿色": "rgba(0, 128, 0, 255)", 
            };
            const currentBgColor = bg_color_map[bgColorName] || "rgba(0, 0, 0, 0)";

            // 文本区域计算时考虑描边宽度
            const effectiveHMargin = horizontalMargin + strokeWidth;
            const effectiveVMargin = verticalMargin + strokeWidth;

            // Step 1: Determine final font size and image dimensions
            let finalImageWidth = imageWidth;
            let finalImageHeight = imageHeight;

            ctx.font = `${fontSize}px ${fontStyle}`; // Initial font for measurement

            if (imageSizeMode === "根据字体大小决定图像尺寸") {
                const textLinesForSizing = prepareLines(ctx, text, charSpacing, orientation);
                const { width: textBlockWidth, height: textBlockHeight } = getTextBlockSize(ctx, textLinesForSizing, charSpacing, lineSpacing, orientation, strokeWidth);
                finalImageWidth = textBlockWidth + (effectiveHMargin * 2);
                finalImageHeight = textBlockHeight + (effectiveVMargin * 2);

                finalImageWidth = Math.max(1, finalImageWidth);
                finalImageHeight = Math.max(1, finalImageHeight);
            } else if (imageSizeMode === "根据图像尺寸决定字体大小") {
                const targetWidth = Math.max(1, imageWidth - (effectiveHMargin * 2));
                const targetHeight = Math.max(1, imageHeight - (effectiveVMargin * 2));

                let testFontSize = 200; // Start large and decrease
                fontSize = 1; // Default to 1 if no size fits

                while (testFontSize > 0) {
                    ctx.font = `${testFontSize}px ${fontStyle}`;
                    // For sizing, ensure automatic line breaks respect target width/height
                    const maxDimForSizing = orientation === "横排" ? targetWidth : targetHeight;
                    const linesForSizing = prepareLines(ctx, text, charSpacing, orientation, maxDimForSizing - (strokeWidth * 2)); // Subtract stroke for inner text area
                    
                    const { width: tbW, height: tbH } = getTextBlockSize(ctx, linesForSizing, charSpacing, lineSpacing, orientation, strokeWidth);

                    let isOverflow = false;
                    if (orientation === "横排") {
                        if ((tbW) > targetWidth || (tbH) > targetHeight) { // Check if text + stroke fits
                            isOverflow = true;
                        }
                    } else { // 竖排
                        if ((tbW) > targetWidth || (tbH) > targetHeight) {
                            isOverflow = true;
                        }
                    }

                    if (isOverflow) {
                        testFontSize -= 1;
                    } else {
                        fontSize = testFontSize;
                        break;
                    }
                    if (testFontSize <= 1) {
                        fontSize = 1;
                        break;
                    }
                }
                ctx.font = `${fontSize}px ${fontStyle}`; // Final font size for drawing
                finalImageWidth = imageWidth;
                finalImageHeight = imageHeight;
            } else { // "字体大小和图像尺寸独立计算"
                ctx.font = `${fontSize}px ${fontStyle}`;
                finalImageWidth = imageWidth;
                finalImageHeight = imageHeight;
            }
            
            // Re-set canvas dimensions
            canvas.width = finalImageWidth;
            canvas.height = finalImageHeight;

            // Fill background
            ctx.fillStyle = currentBgColor;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Determine effective max_text_dim for drawing (for prepareLines)
            const maxTextDim = orientation === "横排" ? (finalImageWidth - (effectiveHMargin * 2)) : (finalImageHeight - (effectiveVMargin * 2));
            const finalLines = prepareLines(ctx, text, charSpacing, orientation, Math.max(1, maxTextDim - (strokeWidth * 2))); // Subtract stroke for inner text area

            // Get actual text block size based on final font size and prepared lines
            const { width: textBlockActualWidth, height: textBlockActualHeight } = getTextBlockSize(ctx, finalLines, charSpacing, lineSpacing, orientation, strokeWidth);
            
            // Calculate start drawing coordinates to center text block within margins
            // Start X/Y for drawing should be adjusted to account for strokeWidth when centering
            const drawStartX = effectiveHMargin + Math.max(0, (finalImageWidth - (effectiveHMargin * 2) - textBlockActualWidth)) / 2;
            const drawStartY = effectiveVMargin + Math.max(0, (finalImageHeight - (effectiveVMargin * 2) - textBlockActualHeight)) / 2;


            // Draw the text
            drawTextManually(ctx, finalLines, drawStartX, drawStartY, colorText, strokeWidth, strokeColorText, opacity, charSpacing, lineSpacing, orientation);

            const count = updateCounter('textImageCount');
            document.getElementById('textImageHelp').innerHTML = `你好，欢迎使用ZML节点~到目前为止，你通过此节点总共添加了${count}次文本图像！！\n\n此工具提取自：“<a href="https://github.com/zml-w/ComfyUI-ZML-Image" target="_blank">https://github.com/zml-w/ComfyUI-ZML-Image</a>”里的节点。\n\n您可以使用浏览器（通常是右键点击图片）来保存生成的图片。祝你天天开心~`;
        }

        function resetTextImageForm() {
            document.getElementById('textImageText').value = 'ZML_文本';
            document.getElementById('textImageFontSize').value = 48;
            document.getElementById('textImageFont').value = "'Noto Sans SC', sans-serif";
            document.getElementById('textImageOpacity').value = 1.0;
            document.getElementById('textImageOpacityValue').textContent = "1.0";
            document.getElementById('textImageColorText').value = '#000000';
            document.getElementById('textImageColorPicker').value = '#000000';
            document.getElementById('textImageStrokeWidth').value = 1;
            document.getElementById('textImageStrokeColorText').value = '#FFFFFF';
            document.getElementById('textImageStrokeColorPicker').value = '#FFFFFF';
            document.getElementById('textImageOrientation').value = '横排';
            document.getElementById('textImageHorizontalMargin').value = 20;
            document.getElementById('textImageVerticalMargin').value = 20;
            document.getElementById('textImageCharSpacing').value = 0;
            document.getElementById('textImageLineSpacing').value = 10;
            document.getElementById('textImageBgColor').value = '透明';
            document.getElementById('textImageSizeMode').value = '根据字体大小决定图像尺寸';
            document.getElementById('textImageWidth').value = 512;
            document.getElementById('textImageHeight').value = 512;
            document.getElementById('textImageLocalFontUpload').value = ''; // Clear local font input
            document.getElementById('textImageLocalFontStatus').textContent = ''; // Clear status
            localFontFamily = null; // Reset global font family tracking
            localFontAdded = false;
            
            // Trigger change event to update visibility of size input fields
            document.getElementById('textImageSizeMode').dispatchEvent(new Event('change'));

            const canvas = document.getElementById('textImageCanvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the canvas
            canvas.width = 0; // Effectively hide canvas
            canvas.height = 0;

            document.getElementById('textImageHelp').innerHTML = `参数已重置。\n\n此工具提取自：“<a href="https://github.com/zml-w/ComfyUI-ZML-Image" target="_blank">https://github.com/zml-w/ComfyUI-ZML-Image</a>”里的节点。\n\n您可以使用浏览器（通常是右键点击图片）来保存生成的图片。祝你天天开心~`;
        }
        
        // ========================================== Tab 切换和区块高亮 ==========================================
        function showTab(tabId) {
            // Hide all tab contents
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.add('hidden');
            });
            // Show the selected tab content
            document.getElementById(tabId + 'Tab').classList.remove('hidden');

            // Deactivate all tab buttons
            document.querySelectorAll('.tab-button').forEach(button => {
                button.classList.remove('active');
            });
            // Activate the corresponding tab button
            if (tabId === 'watermark') {
                document.getElementById('tabButtonWatermark').classList.add('active');
                // Highlight the input section for watermark
                document.getElementById('watermarkInputSection').classList.add('active-section');
                document.getElementById('watermarkInputSection').scrollIntoView({ behavior: 'smooth', block: 'start' });
            } else if (tabId === 'textToImage') {
                document.getElementById('tabButtonTextImage').classList.add('active');
                // Highlight the input section for text image
                document.getElementById('textImageInputSection').classList.add('active-section');
                document.getElementById('textImageInputSection').scrollIntoView({ behavior: 'smooth', block: 'start' });
            }
            // Remove highlight from other sections if any
            document.querySelectorAll('.input-section:not(.active-section)').forEach(section => {
                section.classList.remove('active-section');
            });
            document.querySelectorAll('.output-section:not(.active-section)').forEach(section => {
                section.classList.remove('active-section');
            });
        }

        // Add click listeners to sections for highlighting
        document.querySelectorAll('.section').forEach(section => {
            section.addEventListener('click', function() {
                // Remove highlight from all sections first
                document.querySelectorAll('.section').forEach(s => s.classList.remove('active-section'));
                // Add highlight to the clicked section
                this.classList.add('active-section');
            });
        });

        // ========================================== 主题切换功能 ==========================================
        const themeToggleButton = document.getElementById('themeToggleButton');

        function toggleTheme() {
            document.body.classList.toggle('dark-mode');
            const isDarkMode = document.body.classList.contains('dark-mode');
            localStorage.setItem('theme', isDarkMode ? 'dark' : 'light');
            themeToggleButton.textContent = isDarkMode ? '切换到亮色主题' : '切换到暗色主题';
        }

        // Apply saved theme on page load
        function applySavedTheme() {
            const savedTheme = localStorage.getItem('theme');
            if (savedTheme === 'dark') {
                document.body.classList.add('dark-mode');
                themeToggleButton.textContent = '切换到亮色主题';
            } else {
                // Default to light mode
                document.body.classList.remove('dark-mode');
                themeToggleButton.textContent = '切换到暗色主题';
            }
        }

        // Add event listener for theme toggle button
        themeToggleButton.addEventListener('click', toggleTheme);


        // 页面加载时自动显示第一个tab并初始化相关组件
        document.addEventListener('DOMContentLoaded', () => {
            // 应用保存的主题
            applySavedTheme();

            // 初始显示第一个tab并激活其输入区块
            showTab('watermark'); 

            // 初始调用一次，根据默认值设置全屏水印选项的可见性
            updateWatermarkFullscreenOptionsVisibility();
            // 初始调用一次，根据默认值设置文本图像尺寸输入框的可见性
            document.getElementById('textImageSizeMode').dispatchEvent(new Event('change'));


            // 初始化计数器显示
            const watermarkCount = parseInt(localStorage.getItem('watermarkCount') || '0', 10);
            document.getElementById('watermarkHelp').innerHTML = `你好，欢迎使用ZML节点~到目前为止，你通过此节点总共添加了${watermarkCount}次水印！！\n\n此工具提取自：“<a href="https://github.com/zml-w/ComfyUI-ZML-Image" target="_blank">https://github.com/zml-w/ComfyUI-ZML-Image</a>”里的节点。\n\n您可以使用浏览器（通常是右键点击图片）来保存生成的图片。祝你天天开心~`;

            const textImageCount = parseInt(localStorage.getItem('textImageCount') || '0', 10);
            document.getElementById('textImageHelp').innerHTML = `你好，欢迎使用ZML节点~到目前为止，你通过此节点总共添加了${textImageCount}次文本图像！！\n\n此工具提取自：“<a href="https://github.com/zml-w/ComfyUI-ZML-Image" target="_blank">https://github.com/zml-w/ComfyUI-ZML-Image</a>”里的节点。\n\n您可以使用浏览器（通常是右键点击图片）来保存生成的图片。祝你天天开心~`;

        });

    </script>
</body>
</html>
